# 对象的组合

1. 设计线程安全的类的过程中，需要包含以下三个基本元素：
  - 找到构成对象状态的所有变量
  - 找到约束状态变量的不变性条件
  - 建立对象状态的并发访问管理策略

2. 要分析对象的状态，首先从对象的域开始。如果对象的域包含对象，那么这些状态对象的域也属于对象的状态。

3. 同步策略（Synchronization Policy）定义了如何在不违背对象不变性条件或后验性条件的情况下对其状态的访问操作进行协同。同步策略规定了如何将不可变性、线程封闭与加锁机制等结合起来维护线程安全性，并且还规定了哪些变量由哪些锁来保护。最好将同步策略写成文档，便于后期类的分析和维护。

4. 很多类中都定义了不变性条件，用来判断状态是有效的还是无效的。比如int的取值范围，两数相加的和不能溢出。如果一个不变性条件包含了多个变量，那么在执行任何访问相关变量的操作的时候，都必须持有保护这些变量的锁。

  在操作中还包括一些后验证条件来判断状态迁移是否是有效的。比如自增必须是之前的状态加1。进行几次自增，状态就会加几。如果状态转换和之前状态无关的话，就没有这些验证条件了。

  如果不了解对象的不变性条件与后验条件，那么就不能确保线程安全性。要满足在状态变量的有效值或状态转换上的各种约束条件，就需要借助于原子性与封装性。

  在某些对象的方法中还包含一些基于状态的鲜艳条件。比如不能从空队列中移除一个元素。int变量为最大值时，就不能进行`++`操作。在Java中，等待某个条件为真的各种内置机制（包括等待和通知机制）都与内置加锁机制紧密关联。通常可以通过现有库的类（比如阻塞队列[Blocking Queue]和信号量[Semaphore]）来实现依赖状态的行为。

5. 容器类通常表现出一种”所有权分离“的形式，其中容器类拥有其自身的状态，而客户代码则拥有容器中各个对象的状态。客户需要进行对象的同步。

6. 通过封装机制与合适的加锁机制结合起来，可以确保以线程安全的方式来使用非线程安全的对象。

7. 封闭机制更易于构建线程安全的类，因为当封闭类的状态时，在分析类的线程安全性就无需检查整个程序。

8. Java监视器模式。遵循Java监视器模式的对象会将对象的所有可变状态都封装起来，并由对象自己的内置锁来保护。Java监视器模式的主要优势在于它的简单性。其实对于任何一种锁对象，只要自始至终地使用该所对象，都可以用来保护对象的状态。

9. 使用私有的锁对象而不是对象的内置锁有很多优点。私有的锁对象可以将锁封装起来，使客户端代码无法得到锁，但是客户代码可以通过公有方法来访问锁。

10. 如果一个类是由多个独立且线程安全的状态变量组成，并且在所有的操作中都不包含无效状态转换，那么可以将线程安全性委托给底层的状态变量。

  如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。

  线程是否安全取决于状态变量有哪些不变性条件。

11. 重用JDK基础模块能够降低开发工作量、开发风险（因为现有的类都已经通过测试）以及维护成本。

12. 要为在现有类的基础上添加一个新的原子操作，有几种方法：
  - 修改原始类，这是最安全的一种方法，但是一般无法做到。要修改原始类，就要了解原始类的同步逻辑
  - 继承原始类，这种方法比直接修改原始类更脆弱，因为同步策略被分布到多个单独维护的源文件中
  - 客户端加锁机制（将原始类作为扩展类一个成员），要使用和原始类同步机制相同的锁。比上一个方法更脆弱，因为扩展类与原始类无关
  
  可以使用组合方法来为现有类添加原子操作，在扩展类中提供一套独立的同步策略，以此来保证安全同步。Collections的很多工具类就是这样实现的。

13. 在维护线程安全时，文档是最强大的工具之一。编写文档时，要说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。

14. 如果某个类没有明确地说明是线程安全的，那么就不要假设它是线程安全的。`java.text.SimpleDateFormat`并不是线程安全的。
