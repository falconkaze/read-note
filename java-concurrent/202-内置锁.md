# java内置锁

1. java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。

  每个Java对象都可以用作一个实现同步的锁，称为内置锁（Intrinsic Lock）或监视锁（Monitor Lock）。线程在进入同步代码块之前会自动获取锁，并且在退出同步代码块时自动释放锁（包括正常退出和因为异常退出）。获得内置锁的唯一途径是进入由这个锁保护的同步代码块。

  Java的内置锁相当于一个互斥锁，同一时间最多只有一个线程能够持有这种锁。

2. 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。内置锁是可重入的，也就是说线程尝试获取一个已经由它自己持有的锁，那么这个请求就会成功。重入意味着获取锁的操作的粒度是“线程”，而不是“调用“。重入的一种实现方式是，为每个锁关联一个获取计数值和一个所有者线程。

3. 如果要用同步来协调对某个变量的访问，那么在访问这个变量的所有位置都需要使用同步。而且，当使用锁来协调对某个对象的访问时，在访问变量的所有位置上都要使用同一个锁。

4. 对于每个包含多个变量的不变性条件，其中涉及到的所有变量都需要由同一个锁来保护。

5. 通常，在简单性和性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性。难以维护的代码很难保证安全性。

6. 当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。

7. 同步是通过避免多个线程同时访问可变变量来保证线程安全的。

8. this和super使用的对象锁是同一个。因此当线程获取到this的对象锁后，可以直接访问父类的synchronized方法。如果一个不带synchronized关键字的子类方法内调用了父类的synchronized方法，那么其他线程就不能访问同一个对象子类的synchronized方法。(这儿需要具体研究一下下，super和this对于对象来说究竟算什么)
