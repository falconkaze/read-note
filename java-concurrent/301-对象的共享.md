# 对象的共享

1. 同步是通过避免多个线程同时访问相同的数据。共享和正确地发布对象能够使对象安全地被多个线程同时访问。

2. synchronized关键字不止用来实现原子性或者确定临界区（Critical Section），它还能保证内存可见性。为了保证多个线程之间对内存写入操作的可见性，必须使用同步机制。在没有同步的情况下读取数据，类似于在数据库中使用`READ_UNCOMMITED`隔离级别，以牺牲准确性来获取性能的提升。

3. 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

4. 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机的值。这种安全保证也被称为最低安全性。

  最低安全性适用于大多数变量，但是存在一个例外：非volatile类的64位数值变量double和long。Java内存模型要求，变量的读取操作和写入操作必须都是原子操作，但是对于非volatile类型的long和double变量，JVM允许将64位的读操作和写操作分解为两个32位的操作。因为编写Java虚拟机规范时，许多主流处理器框架还不能有效地支持64位数值的原子操作。

5. volatile关键字，用来确保将变量的更新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量与其他内存操作一起重排序。volatile不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总是会返回最新写入的值。

  volatile是一种比synchronized更轻量级的同步机制。加锁机制可以保证可见性又可以保证原子性，而volatile变量只能保证可见性。

6. 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，就不要使用volatile变量。volatile变量的的正确使用方式包括：确保它们生命周期的可见性，确保它们所引用对象的状态的可见性，以及一些重要的程序生命周期时间的发生（例如，初始化或关闭）。例如：根据一个布尔状态值判断是不是应该结束循环。

  当且仅当满足以下所有条件时，才应该使用volatile变量：
  - 对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。
  - 该变量不会与其他状态变量一起纳入不变性条件中
  - 在访问变量时不需要加锁。

7. 对于服务端应用程序，无论在开发阶段还是测试阶段，当启动JVM一定要执行`-server`选项。server模式下的JVM比client模式下的JVM进行更多的优化。

8. 发布（Publish）一个对象是指：使对象能够在当前作用域之外的代码中使用。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。当不应该发布的对象被发布时，这种情况称为逸出（Escape）。

9. 当发布一个对象时，可能会间接发布其他对象。

  不要在构造过程中使this引用逸出。只有当构造函数返回时，this引用才应该从线程中逸出。构造函数可以将this引用保存到某个地方，只要其他线程不会在构造函数完成之前调用它。
  - 发布一个内部类的实例会隐式地导致this引用逸出。
  - 在构造函数中创建线程时（显式创建或隐式创建）会导致this引用被新的线程共享。可以在构造函数中创建线程，但是最好不要立即启动它，而是通过一个start方法或initialize方法启动。
  - 在构造函数中调用一个可改写的**实例**方法时（既不是private方法，也不是final方法），同样会导致this应用在构造过程中逸出。

10. 封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得复杂。

11. 一种避免同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步。这种技术称为线程封闭。Swing使用了大量的线程封闭技术，JDBC的Connection对象也使用了线程封闭技术。

  Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。

  栈封闭是线程封闭的一种特例。在栈封闭中，只有通过局部变量才能访问对象。

  使用ThreadLocal来维持线程安全。当线程终止后，其中的值会作为垃圾回收（如果是线程池呢？？）。ThreadLocal变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，使用时要格外小心。

12. 使用不可变对象也不用进行同步。不可变对象：对象被创建后就不能被改变。线程安全性是不可变对象的固有属性之一。不可变对象返回的状态对象永远是副本。

  满足以下三个条件时，对象才是不可变的：
  - 对象创建以后其状态就不可被修改
  - 对象的所有域都是final类型
  - 对象是正确创建的（在对象的创建期间，this引用没有溢出）

  String并不是所有域都声明为final，String会将hash值的计算推迟到第一次调用hashCode时进行，因为String的字符数组不会变，无论什么时候计算hashCode，算出的值都是同一个。

13. 除非需要更高的可见性，否则应该将所有的域都声明为私有域。除非需要某个域是可变的，否则应将其声明为final域。

14. 对于在访问和更新多个状态变量时出现的竞态条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。不可变对象在创建结束后就固定了，不会再改变。使用不可变对象作为公有状态时，最好使用volatile或者final，保证多个线程看到的对象是同一个。构造不可变对象时，不能直接使用外部对象作为其状态，要使用其拷贝（深拷贝），返回状态时，也要返回拷贝出的对象的引用，不能直接返回状态对象的引用。

15. 要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：
  - 在静态初始化函数中初始化一个对象引用。
  - 将对象的引用保存到volatile类型的域或者AtomicReference对象中
  - 将对象的引用保存到某个正确构造对象的final类域中
  - 将对象的引用保存到一个由锁保护的域或容器中，比如ConcurrentMap

16. 如果对象在发布后不会被修改，那么对于其他在没有额外同步的情况在安全地访问这些对象的线程来说，安全发布是足够的。所有的安全发布机制（上面这几种）都能保证，当对象的引用对所有访问该对象的线程可见时，对象发布时的状态对于其他线程也是可见的，并且如果对象状态不会再变，那么就足以确保任何访问都是安全。

  如果对象从技术上看是可变的，但其状态在发布后不会再改变，那么这种对象称为事实不可变对象。在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象（因为它的表现和不可变对象一样，只是靠人为来控制）。如果方法中会修改对象的状态，这个对象并不是事实不可变对象（比如SimpleDateFormat）。

17. 要安全地共享可变对象，这些对象必须被安全地发布，并且必须是线程安全的或者由某个锁保护起来。

18. 对象的发布需求取决于它的可见性：
  - 不可变对象可以通过任意机制来发布
  - 事实不可变对象，必须通过安全方式来发布
  - 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来

19. 在并发程序中使用和共享对象时，可以使用一些实用的策略：
  - 线程封闭
  - 只读共享，不可变对象和事实不可变对象
  - 线程安全共享。线程安全的对象在其内部实现同步
  - 保护对象。被保护的对象只能通过持有特有的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。
