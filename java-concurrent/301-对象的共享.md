# 对象的共享

1. 同步是通过避免多个线程同时访问相同的数据。共享和正确地发布对象能够使对象安全地被多个线程同时访问。

2. synchronized关键字不止用来实现原子性或者确定临界区（Critical Section），它还能保证内存可见性。为了保证多个线程之间对内存写入操作的可见性，必须使用同步机制。在没有同步的情况下读取数据，类似于在数据库中使用`READ_UNCOMMITED`隔离级别，以牺牲准确性来获取性能的提升。

3. 在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

4. 当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机的值。这种安全保证也被称为最低安全性。

  最低安全性适用于大多数变量，但是存在一个例外：非volatile类的64位数值变量double和long。Java内存模型要求，变量的读取操作和写入操作必须都是原子操作，但是对于非volatile类型的long和double变量，JVM允许将64位的读操作和写操作分解为两个32位的操作。因为编写Java虚拟机规范时，许多主流处理器框架还不能有效地支持64位数值的原子操作。

5. volatile关键字，用来确保将变量的更新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量与其他内存操作一起重排序。volatile不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总是会返回最新写入的值。

  volatile是一种比synchronized更轻量级的同步机制。加锁机制可以保证可见性又可以保证原子性，而volatile变量只能保证可见性。

6. 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，就不要使用volatile变量。volatile变量的的正确使用方式包括：确保它们生命周期的可见性，确保它们所引用对象的状态的可见性，以及一些重要的程序生命周期时间的发生（例如，初始化或关闭）。例如：根据一个布尔状态值判断是不是应该结束循环。

  当且仅当满足以下所有条件时，才应该使用volatile变量：
  - 对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。
  - 该变量不会与其他状态变量一起纳入不变性条件中
  - 在访问变量时不需要加锁。

7. 对于服务端应用程序，无论在开发阶段还是测试阶段，当启动JVM一定要执行`-server`选项。server模式下的JVM比client模式下的JVM进行更多的优化。

8. 发布（Publish）一个对象是指：使对象能够在当前作用域之外的代码中使用。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。当不应该发布的对象被发布时，这种情况称为逸出（Escape）。

9. 当发布一个对象时，可能会间接发布其他对象。

  不要在构造过程中使this引用逸出。只有当构造函数返回时，this引用才应该从线程中逸出。构造函数可以将this引用保存到某个地方，只要其他线程不会在构造函数完成之前调用它。
  - 发布一个内部类的实例会隐式地导致this引用逸出。
  - 在构造函数中创建线程时（显式创建或隐式创建）会导致this引用被新的线程共享。可以在构造函数中创建线程，但是最好不要立即启动它，而是通过一个start方法或initialize方法启动。
  - 在构造函数中调用一个可改写的**实例**方法时（既不是private方法，也不是final方法），同样会导致this应用在构造过程中逸出。

10. 封装能够使得对程序的正确性进行分析变得可能，并使得无意中破坏设计约束条件变得复杂。

11. 一种避免同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步。这种技术称为线程封闭。Swing使用了大量的线程封闭技术，JDBC的Connection对象也使用了线程封闭技术。
