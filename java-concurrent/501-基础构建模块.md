# 基础构建模块

1. `Collections.synchronized**`这些类实现线程安全的方式是：将它们的状态封装起来，并对每个共有方法都进行同步，使得每次只有一个线程能够访问容器的状态。它们都属于同步容器类。

2. 容器上常见的复合操作包括：迭代、跳转（根据指定顺序找到当前元素的下一个元素）以及条件运算。

3. 当容器在迭代过程中发现被修改，就会抛出ConcurrentModificationException异常，不仅在并发中会出现，如果在迭代过程中不是使用`Iterator.remove`方法来移除元素的话，也会出现这个异常。

  对于共享容器，为了避免这种情况，可以对迭代操作加锁（注意使用正确的锁），但是如果容器迭代处理过程比较久，会导致锁竞争激烈，系统吞吐量降低。另一种方法是克隆容器（克隆过程需要加锁，具体是深拷贝还是浅拷贝取决与需求），并在副本上进行迭代。

  对于共享容器来说，在其所有进行迭代的地方都需要加锁，要特别注意迭代器隐藏的情况。比如`for each`循环，容器的hashCode、equals和toString方法。当容器作为另一个容器的元素或者键值时，要特别注意（比如容器放入Set中，就会调用hashCode和equals方法）。

4. 封装对象的状态有助于维持不变性，封装对象的同步机制也有利于确保实现同步策略。

5. 同步容器将所有对容器状态的访问都串行化，以实现它的线程安全性，这种方法会严重降低并发性，当多个线程竞争时，降低程序的吞吐量。

  并发容器是针对多个线程并发访问设计的。通过并发容器来替代同步容器，可以极大提高伸缩性并降低风险。

6. ConcurrentHashMap使用了一种粒度更细的加锁机制（分段锁）来实现更大程度的共享。它能在并发访问环境下实现更高的吞吐量，而在单线程环境中只损失很小的性能。（同步容器相当于数据库的表级锁，会锁住全部的数据，而ConcurrentHashMap只锁一部分）

7. ConcurrentHashMap和其他并发容器提供的迭代器不会抛出ConcurrentMofificationException，因此不需要在迭代过程中对容器加锁，这种迭代器具有弱一致性，而非及时失败。弱一致性的容器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但是不保证）在迭代器被构造后将修改操作反映给容器。

  对于一些需要在整个Map上计算的方法，例如size和isEmpty，它们返回的结构在计算时可能已经失效了，只能看做一个近似值。由于并发容器一直处于变化中，这些值总在变化，因此这些操作的需求被弱化了，换来的是get、put、remove等操作性能的提升。

  只有当应用程序需要加锁Map以进行独占访问或者需要依赖同步Map带来的一些其他作用时，才应该放弃是使用ConcurrentHashMap。

8. CopyOnWriteArrayList用于替代同步List。

  “写入时复制“容器的线程安全性在于，只要正确地发布一个事实不可变对象（这里指的是List底层的数组），那么在访问该对象时就不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而保证可变性。

  ”写入时复制”容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素与创建迭代器时的元素完全一致。这些容器每次修改容器时都会复制底层数组，这需要一定的开销。仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。

9. 队列可以使有界的，也可以是无界的。无界队列永远不会充满，所以无界队列的put方法永远不会被阻塞。

  阻塞队列支持生产者-消费者这种设计模式，这种设计模式将生产和消费解耦，使得代码逻辑更加清晰。

  在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能抑制并防止产生更多的工作项，使应用程序在负荷过载的情况下变得更加健壮。

  如果阻塞队列并不完全符合设计需求，那么还可以通过信号量（Semaphore）来创建其他的阻塞数据结构。

10. 对于可变对象，生产者-消费者这种设计和阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者转移给消费者。线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来“转移所有权”（需要保证，发布对象的线程不会再访问它，保证新的线程拥有独占权）。

  对象池利用了串行线程封闭，将对象“借给”一个请求线程，只要对象池包含足够的内部同步来安全地发布池中的对象，并且只要客户代码本身不会发布池中的对象，并在归还对象后不再使用它，那么就可以安全地在线程之间转移所有权。

  也可以使用其他发布机制来传递可变对象的所有权，但必须确保只有一个线程接受被转移的对象。

11. Deque是一种双端队列，实现了在队列头和队列尾的高效插入和移除。

  阻塞队列适合生产者-消费者模式，双端队列适合工作密取（Work Stealing）模式。生产者-消费者模式中，所有消费者共享一个工作队列，而在工作密取模式中，每个消费者都有各自的双端队列，如果消费者完成了自己双端队列中的任务，可以从其他消费者的双端队列末尾获取工作。密取工作模式比传统的生产者-消费者模式具有更高的可伸缩性（因为工作线程不会在单个共享的队列上发生竞争，另外工作者访问其他队列时，会从队列尾部获取工作）。

  工作密取非常适合既是生产者又是消费者的问题（例如爬虫，搜索图算法，遍历树）。

12. 线程可能会阻塞或暂停执行，原因有很多：等待I/O操作结束，等待获取一个锁，等待从Thread.sleep方法中醒来，或者等待另一个线程的计算结果。当线程被阻塞时，它通常被挂起，并处于某种阻塞状态（`BLOCKED`、`WAITING`或`TIMED_WAITING`。

13. BlockingQueue的put和take方法等方法会抛出受检查异常Interrupted-Exception。当某方法抛出Interrupted-Exception时，表示该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。

  中断是一种协同机制，一个线程不能强迫其他线程停止正在执行的操作而去执行其他操作。最常使用中断的操作就是取消某个操作。

14. 当代码中调用了一个会抛出InterruptedException的方法时，调用方法也就变成了一个阻塞方法，并且必须要处理对中断的响应。对于库函数来说，有两种基本选择：传递InterruptedException、恢复中断（调用当前线程的interrupt方法）。

15. 在容器类中，阻塞队列是一种特殊的类：它们不仅作为容器，还能协调生产者和消费者线程之间的控制流。

  同步工具类可以是任何一个对象，只要它们根据自身的状态来协调线程的控制流。同步工具类包括：阻塞队列、信号量（Semaphore）、栅栏（Barrier）以及闭锁（Latch）。

  所有的同步工作类都包含了一些特定的结构化属性：它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。

16. 闭锁可以阻塞线程直到其到达终止状态。闭锁可以用来确保某些活动知道其他活动都完成后才继续执行。
  - 确保某个计算在其需要的所有资源都被初始化之后才继续执行
  - 确保某个服务在其依赖的所有其他服务都已经启动之后才继续执行
  - 等待知道某个操作的所有参与者都就绪再继续执行。

17. FutureTask也可以做闭锁。FutureTask表示的计算是通过Callable（一种可以返回结果，抛出异常的Runnable）实现的 ，并且可以处于三种状态：等待运行，正在运行和运行完成（包括因取消而结束和因异常结束）。当FutureTask进入完成状态后，它会停留在这个状态上。

  无论Callable中抛出什么异常，都会被封装到一个ExecutionException中。

18. 计数信号量（Counting Semaphore）用来控制同时访问某个特殊资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。

  Semaphore中管理者一组虚拟的许可（permit），许可的初始数量可以通过构造器指定，在执行操作时可以首先获取许可（acquire），并在使用时释放许可（release）。如果没有许可，那么线程会阻塞，直到被中断或者操作超时。

  计算信号量的一种简化形式是二值信号量，即初始值为1的Semaphore。二值信号量可以用作互斥体（mutex），并具备不可重入的加锁语义。

19. 闭锁是一种一次性对象，一旦进入终止状态，就不能被重置。栅栏（Barrier）类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏和闭锁的区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。栅栏用于实现一些协议（例如：游戏匹配到足够的人后，还需要所有人确认就绪才会进入游戏）。

  CyclicBarrier可以使一定数量的参与者反复地在栅栏位置汇集，它在并行计算中非常有用。例如：某个步骤中的计算可以并行执行，但是必须等到该步骤中的所有运算都执行完毕才能进入下一个步骤。

  另一种形式的栅栏是Exchanger，它是一种两方（Two-party）栅栏，各方在栅栏位置上交换数据。当两方执行不对称的操作时，Exchanger会非常有用。
