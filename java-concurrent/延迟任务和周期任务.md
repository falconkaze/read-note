# java延迟任务和周期任务

1. Timer类可以管理延迟任务和周期任务，但是它存在一些缺陷，应该考虑使用ScheduledThreadPoolExecutor来代替它。

  Timer支持基于绝对时间而不是相对时间的调度机制，因此任务的执行对于系统时钟变化比较敏感，而ScheduledThreadPoolExecutor只支持基于相对时间的调度。

  Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间太长，那么将破坏其他TimerTask的定时准确性。例如：一个周期任务需要每10s执行一次，但是某次执行花费了40s。根据不同的调度策略（基于固定速率来调度还是基于固定延时来调度）会导致在40秒后是快速连续调用4次或者彻底丢弃4次调用。

  Timer线程不会捕获异常，因此TimerTask如果抛出一个未检查的异常，就会终止定时线程。这种情况下，Timer也不会恢复线程的执行，而是错误地任务整个Timer被取消了。因此已经被调度但尚未执行的TimerTask将不会被执行，新的任务也不会被调度，这个问题被称为”线程泄露“。

2. 如果需要构建自己的调度任务，可以使用DelayQueue，可以使用DelayQueue，它实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能，DelayQueue管理着一组Delayd对象。每个Delayed对象都有一个相应的延迟时间：在DelayQueue中，只有某个元素逾期后，才能从一个DelayQueue中执行take操作；返回的对象根据延迟时间来排序。
