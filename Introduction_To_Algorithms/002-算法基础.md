# 算法基础

1. 在伪代码中，我们使用最清晰、最简洁的表示方法来说明给定的算法。伪代码通常不关心软件工程的问题。为了更简洁地表达算法的本质，常常忽略数据抽象、模块性和错误处理的问题。

2. 伪代码中的一些规定：

    - 缩进表示块结构

    - A[1...j] 表示 A 的一个子数组，包含两个边界

    - return 可以返回多个值

    - error 表示出现错误

3. 循环不变式主要用来帮助我们理解算法的正确性。关于循环不变式，必须要证明三条性质：

    a. 初始化：循环的第一次迭代前，它为真

    b. 保持：如果循环的某次迭代之前为真，那么下次迭代之前它仍为真

    c. 终止：在循环终止时，循环不变式为我们提供了一个有用的特性，该性质有助于证明算法的正确性

    这个过程类似于数学归纳法，但是又不同。数学归纳法中，归纳步（第二步）是无限的，不会结束；而循环不变式的证明最后会结束，要证明结束状态是正确的。

4. 分析算法是为了预测算法所需要的资源（计算时间，内存，通信带宽，计算机硬件等），然后挑选出一种相对更优的算法。

5. 在能够分析一个算法之前，我们必须要有一个要使用的实现技术的模型，包括描述所用资源及其代价的模型。使用模型的目的是：简化分析成本，突出本质；独立于特定计算机及语言；公平公正的评判标准。

6. 一般来说，算法需要的时间与输入的规模同步增长，所以通常把一个程序的运行时间描述成其输入规模的函数。这里的输入规模依赖于研究的问题。一个算法在特定输入上的运行时间是指执行的操作数或步数。

7. 即使对于给定规模的输入，一个算法的运行时间也可能依赖特定的输入，存在最佳情况和最差情况。

8. 一般来说，我们只考虑最坏情况的运行时间。有三个理由：
   
    - 最坏情况的运行时间给出了任意输入的运行时间的一个上界。

    - 对于某些算法，最坏情况经常出现。例如数据库检索，有经常找不到数据的场景。

    - “平均情况”往往和最坏情况大致一样差。

9. 一般来说衡量算法的优劣只看其运行时间表达式中增长量级最大的一项。对于很多时间复杂度更高的算法来说，其常数项和低阶项较小，在数量级较小时更占优势。

10. 当一个算法包含对自身的递归调用时，它的运行时间往往可以通过递归方程来表示，利用较小输入上的运行时间来描述规模为 n 的问题的运行时间。假设把原问题分解成 a 个子问题，每个子问题的规模是原问题的 1/b。T(n) 表示求解 n 规模的原问题的运行时间，D(n) 表示分解问题的耗时，C(n) 表示合并解的耗时。则递归公式如下：

$$
T(n) = \begin{cases}
O(1) \quad\quad\quad\quad\quad\quad\quad\quad\quad\ 若n<=c\\
aT(n/b) + D(n) + C(n) \quad其他\\
\end{cases}
$$
