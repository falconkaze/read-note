* Schema 与数据类型优化

良好的逻辑设计和物理设计是高性能的基石，应该根据系统要执行的查询语句来设计 schema，这往往需要权衡各种因素。例如：反范式的设计可以加快某些类型的查询，但同时可能会使另一种类型的查询变慢；比如添加计数表和汇总表是一种很好的优化查询的方式，但是这些表的维护成本可能会很高。

** 选择数据类型

*** 选择数据类型的几个原则

**** 最小的通常更好

更小的数据类型通常更快，因为它们占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少。但是要确保没有低估需要存储的值的范围，因为在 schema 中的许多地方增加数据类型的范围是一个非常耗时和痛苦的操作。

**** 简单就好

简单数据类型的操作通常需要更少的 CPU 周期。例如：整数比字符操作代价更低。推荐使用 MYSQL 内建的类型而不是字符串类型来保存时间；应该用整型存储 IP 地址。

**** 尽量避免 NULL

如果查询中包含可能为 NULL 的列，对 MySQL 来说更难优化，因为可为 NULL 的列使得索引、索引统计和值比较都更复杂。可为 NULL 的列会使用更多的存储空间。当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节。

通常把可为 NULL 的列改为 NOT NULL 带来的性能提升会比较小，没有必要优先进行优化。

InnoDB 使用单位的位（bit）来存储 NULL 值，所以对于稀疏数据有很好的空间效率，但这一点不适用于 MyISAM。

**** 选择数据类型时，第一步先确定合适的大类型，第二步选择具体的类型（长度，范围，精度等其他特性）。

*** 整数类型

整数类型有可选的 UNSIGNED 属性，合理利用可以有效节省空间。

MySQL 的整数计算一般使用 64 位的 BIGINT 整数，即使在 32 位环境也是如此。（一些聚合函数例外，它们使用 DECIMAL 或 DOUBLE 进行计算）。

MySQL 可以为整数类型指定宽度，如 INT(11)。这点不会限制值的合法范围，只是规定了 MySQL 的一些交互工具用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的。

*** 实数类型

实数类型不只是为了存储小数部分，也可以使用 DECIMAL 来存储比 BIGINT 还大的整数。MySQL 既支持精确类型，也支持不精确类型。

在 MySQL 5.0 和更高的版本，DECIMAL 类型支持精确计算。因为 CPU 不支持对 DECIMAL 的直接计算，而 CPU 直接支持原生浮点计算，所以浮点运算明显更快。

浮点和 DECIMAL 类型都可以指定精度。对于 DECIMAL 列，可以指定小数点前后所允许的最大位数。MySQL 5.0 和更高版本将数字打包保存到一个二进制字符串中（每 4 个字节保存 9 个数字）。例如，DECIMAL(18,9) 共使用 9 个字节：整数部分 4 个字节，小数部分四个字节，小数点本身占一个字节。MySQL 5.0 和更高版本中的 DECIMAL 类型允许最多存储 65 个数字。

有多种方法可以指定浮点列所需要的精度，这会使得 MYSQL 悄悄选择不同的数据类型，或者在存储时对值进行取舍。这些精度是非标准的、所以建议只指定数据类型，不指定精度。

MySQL 使用 DOUBLE 作为内部浮点计算的类型。

要保证精度有两种办法：一种是使用 DECIMAL；另一种是将数字乘以 10 的倍数，然后保存到 BIGINT 中。

*** 字符串类型

从 MySQL 4.1 开始，每个字符串列都可以定义自己的字符集和排序规则。 

**** VARCHAR 和 CHAR 类型

VARCHAR 和 CHAR 在磁盘和内存中的存储方式与存储引擎的具体实现有关。注意：存储引擎存储 CHAR 或者 VARCHAR 的方式在内存中和在磁盘上可能不一样，所以 MySQL 服务器从存储引擎读出的值可能需要转换为另一种存储格式。

***** VARCHAR

VARCHAR 类型用于存储可变长字符串，它只使用必要的空间。但是如果 MySQL 表使用 ROW_FORMAT=FIXED 创建的话，每一行都会使用定长存储，这会很浪费空间。

VARCHAR 类型需要使用 1 到 2 个字节来记录字符串的长度：如果列的最大长度小于或等于 255 字节，就只需要一个字节来表示，否则使用 2 个字节。

VARCHAR 节省了存储空间，对性能有帮助。但是由于行是变长的，在 UPDATE 时可能变得比原先长，如果原先的空间无法容纳的话，就需要额外的工作。对于这点，不同的存储引擎的处理方式是不同的。

适合使用 VARCHAR 的场景：字符串列的最大长度比平均差高度大很多；列的更新很少，所以碎片不是问题；使用了像 UTF-8 这样复杂的字符集，每个字符都使用不同的字节数进行存储。

在 5.0 或者更高版本，MySQL 在存储和检索时会保留末尾空格。但是在 4.1 或更老的版本，MySQL 会剔除末尾空格。

但在查询字符串的时候，字符串尾部的空格不会影响 VARCHAR 和 CHAR 的查询。

InnoDB 更加灵活，它可以把过长的 VARCHAR 存储为 BLOB。

***** CHAR

CHAR 类型是定长的：MySQL 总是根据定义的字符串长度分配足够的空间。当存储 CHAR 值时，MySQL 会删除尾部的空格。CHAR 值会根据需要采用空格进行填充以方便比较。

CHAR 很适合存储很短的字符串，或者所有值都接近一个长度的字符串。对于经常变更的数据，CHAR 也比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。对于非常短的列，CHAR 比 VARCHAR 在存储空间上也更有效率，比如 CHAR(1) 比 VARCHAR(1) 占用的空间小。

数据如何存储取决于存储引擎，并非所有的存储引擎都会按照相同的方式来处理定长和变长的字符串。不过填充和截取空格的行为在不同存储引擎都是一样的，因为这是在 MySQL 服务器层处理的。

与 CHAR 和 VARCHAR 类似的类型有 BINARY 和 VARBINARY，它们存储的是二进制字符串。二进制字符串存储的是字节码而不是字符。填充也不一样：MySQL 填充 BINARY 采用的是 \0 而不是空格，在检索时也不会去掉填充值。

二进制比较的有事并不仅仅体现在大小写敏感上。MySQL 比较 BINARY 字符串时，每次按一个字节，并且根据该字节的数值进行比较。因为二进制比较比字符比较（字符比较需要考虑字符排序规则）简单得多，所以也就更快。

VARCHAR(5) 和 VARCHAR(100) 在存储 'hello' 时消耗的磁盘空间是相同的，但是更长的列会消耗更多的内存，因为 MySQL 通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。
