* 创建高性能的索引

索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。索引优化应该是对查询性能优化最有效的方式了。索引能够轻易将查询性能提升好几个数量级，“最优”的索引有时候比一个“好的”索引性能要好两个数量级。创建一个真正“最优”的索引经常需要重写查询。

与传统的硬盘驱动器相比，固态硬盘驱动器有着完全不同的性能特性。

** 索引基础

在 MySQL 中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。也就是说，MySQL 会先在索引上按值进行查找，然后返回所有包含该值的数据行。

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能高效地使用索引的最左前缀列。

*** 索引的类型

在 MySQL 中，索引是在存储引擎层而不是服务器层实现的，所以没有统一的索引标准。不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层实现也可能不同。

**** B-Tree 索引

谈起 MySQL 中的索引，如果没有特别指定类型，一般说的都是 B-Tree 索引，它使用 B-Tree 这种数据结构来保存数据。实际上很多存储引擎使用的是 B+Tree，InnoDB 使用的是 B+Tree 数据结构，NDB 集群存储引擎内部实际上使用了 T-Tree 结构存储这种索引。

存储引擎以不同的方式使用 B-Tree 索引，性能也各有不同。例如：MyISAM 使用前缀压缩技术使得索引更小，但 InnoDB 则按照原数据格式进行存储。MyISAM 索引通过数据的物理位置引用被索引的行，而 InnoDB 根据主键引用被索引的行。

B-Tree 通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。B-Tree 索引能够加快访问数据的的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根结点开始进行搜索。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子叶节点中值的上限和下限。叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。树的深度和表的大小直接相关。

B-Tree 对索引列是顺序组织和存储的，所以很适合查询范围数据。

可以使用 B-Tree 索引的查询类型：B-Tree 索引适用于全键值、键值范围或键前缀查找，其中键前缀查找只适用于根据最左前缀查找。

因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的 ORDER BY 操作。一般来说，如果 B-Tree 可以根据某种方式查找到值，那么也可以根据这种方式用于排序。如果 ORDER BY 子句满足上面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

B-Tree 索引的一些限制：

1. 如果不是按照索引的最左列开始查找，则无法使用索引。

2. 不能跳过聚合索引中的列。

3. 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询。

在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。

**** 哈希索引

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效（不支持范围查询）。哈希索引将所有的哈希码存储到索引中，同时在哈希表中保存指向每个数据列的指针。

在 MySQL 中，只有 Memory 引擎显示支持哈希索引，这也是 Memory 引擎表的默认索引类型，Memory 引擎同时也支持 B-Tree 索引。

哈希索引的优点：由于哈希索引基于哈希表，所以继承了哈希表的优点，查询速度快，因为索引自身只需要存储对应的哈希值，索引索引的结构十分紧凑（也有助于查询速度）。

哈希索引的缺点：

1. 哈希索引只存储哈希值和行指针，不存储字段值，所以不能使用索引中的值来避免读取行。不过访问内存中的行速度很快，一般对性能影响不大。

2. 哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序。

3. 哈希索引也不支持部分索引列匹配查找，因为它是用所有的数据列来计算哈希值的。

4. 哈希索引只支持等值比较查询，不支持任何范围查询。

5. 访问哈希索引的数据非常快，除非出现很多哈希冲突。

6. 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。

哈希索引只适用于某些特定的场合。比如：在数据仓库应用中有一种经典的“星型”schema，需要关联很多查找表，哈希索引非常适合查找表的需求。

InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”。当 InnoDB 注意到某些索引值被使用得非常频繁时，它会在内存中基于 B-Tree 索引之上再创建一个 哈希索引，这就让 B-Tree 索引也具有哈希索引的一些优点。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，可以关闭这个功能。

***** 创建自定义哈希索引

如果存储引擎不支持哈希索引，可以模拟像 InnoDB 一样创建哈希索引。使用哈希表的原理来对一些特殊的列来进行查询优化。这种方法适用于对一些很长的列进行优化。

具体步骤如下：

1. 数据表中新增一列用来保存另一列的 hash 值，并对新增的列添加索引。选择合适的 hash 函数（例如 CRC32() 函数）来为优化列生成对应的索引列。

2. 查询时需要查询 hash 列和原先列。查询原先列是考虑到了 hash 冲突的情况。

这种方法的缺点是需要维护哈希值，可以手动维护，也可以使用触发器实现。如果数据量非常大，CRC32() 会出现大量的哈希冲突，可以考虑自己实现一个简单的 64 位哈希函数。可以使用 MD5() 函数返回值的一部分作为自定义哈希函数。

**** 空间数据索引(R-Tree)

MyISAM 表支持空间索引，可以用作地里数据存储。和 B-Tree 索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据。查询时可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 相关函数如 MBRCONTAINS() 等来维护数据。开源关系数据库中对 GIS 的解决方案做的比较好的是 PostgreSQL 的 PostGIS。

**** 全文索引

全文索引是一种特殊的索引，它查找的是文本中的关键字，而不是直接比较索引中的值。全文索引和其他基类索引的匹配方式完全不同，它有许多需要注意的地方：停用词、词干和复数、布尔搜索等。全文索引更类似与搜索引擎做的事。

在相同的列上同时创建全文索引和基于值的 B-Tree 索引不会有冲突，全文索引适用于 MATCH AGAINST 操作，而不是普通的 WHERE 条件操作。

**** 其他索引类别

还要很多第三方的存储引擎使用不同类型的数据结构来存储索引。例如 TokuDB 使用分形树索引（fractal tree index），这是一类较新开发的数据结构，既有 B-Tree 的很多优点，也避免了 B-Tree 的一些缺点。

** 索引的优点

索引的优点如下：

1. 索引可以帮助快速定位数据的存储位置，大大减少服务器所需要扫描的数据量。

2. 索引（某些索引索引）可以帮助服务器避免排序和临时表。

3. 索引（某些索引）可以将随机 I/O 变为顺序 I/O。因为数据有序，相关的数据都存在一块。

索引的星级：三星，索引中的列包含了查询中需要的所有列；二星，索引中的数据顺序和查找中的排序顺序一致；一星，索引将相关的记录放到一起。

索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型表，建立和使用索引的代价将随之增长。这种情况下，需要一种技术可以直接区分处查询需要的一组数据，而不是一条记录一条记录地匹配。例如：分区技术。

如果表的数量非常多，可以建立一个元数据信息表，用来查询需要用到的某些特性。对于 TB 级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引。

** 高性能的索引策略

正确地创建和使用索引是实现高性能的基础。

*** 独立的列

如果查询中的列不是独立的，则 MySQL 不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。

*** 前缀索引和索引选择性

有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是模拟哈希索引，另一个方法是索引开始的部分字符，但是这样会降低索引的选择性。

索引的选择性是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1。索引的选择性越高，查询效率越高。唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。

一般情况下，某个列前缀的选择性也是足够高的，足以满足查询性能。对于 BLOB、TEXT 或者很长的 VARCHAR 类型的列，必须使用前缀索引，因为 MySQL 不允许索引这些列的完整长度。

前缀长度的选择要保证较高的选择性，但也不能太长（空间，效率）。

为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较（保证最常见的前缀列与与最常见的值的前缀差不多）。另一种方法是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性（不要只看平均选择性，也要考虑最坏情况下的选择性）。

前缀索引是一种能让索引更小、更快的有效方法，但是另一方面也有缺点：MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。

有时候后缀索引也是有用途（比如，找到某个域名的所有电子邮箱地址）。MySQL 原生并不支持反省索引，但是可以把字符串反转后存储，并基于此建立前缀索引。可以通过触发器来维护这种索引。

*** 多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高 MySQL 的查询性能。MySQL 5.0 和更新的版本引入了一种加“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。查询能同时使用多个单列索引进行扫描，并将结果进行合并。这种算法由三个变种：OR 条件的合并（UNION），AND 条件的合并（intersection），组合前两种情况的联合及相交。

索引合并有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕：

1. 当出现服务器对多个索引做相交操作时（通常有多个 AND 条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。

2. 当服务器需要对多个索引做联合操作时，通常需要耗费大量 CPU 和内存资源在算法的缓存、排序和合并操作上。特别是其中有些索引的选择性不高，需要合并扫描返回的大量数据时。

3. 更重要的是，优化器不会把这些计算到“查询成本”（cost）中，导致该执行计划还不如直接走全表扫描。

如果在 EXPLAIN 中看到有索引合并，应该好好检查一下查询和表的结构，看是不是已经是最优的。也可以通过参数 optimizer_switch 来关闭索引合并功能。也可以使用 IGNORE INDEX 提示让优化器忽略掉某些索引。

*** 选择合适的索引列顺序

索引列正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。

对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。这个建议在某些场景可能有帮助，但通常不如避免随机 I/O 和排序那么重要，考虑问题需要更全面（场景不同则选择不同，没有一个放之四海皆准的法则）。

当不考虑排序和分组的时候，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化 WHERE 条件的查找。然而，性能不只是依赖与所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值的分布有关。

在某些应用程序中，对于没有登录的用户，都将其用户名记录为”guest“。系统账号也会导致类似的问题一些系统中，所有用户都是系统用户的好友，这样方便给所有用户发送状态通知或其他消息。经验法则和推论在多数情况下都是有效的，但是注意不要假设平均情况下的性能也能代表特殊情况下的性能，特殊情况可能会摧毁整个应用的性能。

最后，尽管关于选择性和基数的经验法则值得去研究和分析，但一定要记住别忘了 WHERE 子句中的排序、分组和范围条件等其他因素。

*** 聚簇索引

聚簇索引不是一种单独的索引类型，是一种数据存储方式。具体的细节依赖于实现方式，InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

InnoDB 通过主键聚集数据。如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录，包含相邻键值的页面可能会相距甚远。

聚簇主键可能对性能有帮助，但也可能导致严重的性能问题。所以需要仔细地考虑聚簇索引，尤其是将表的存储引擎从 InnoDB 改成其他引擎的时候（反过来也一样）。

聚集的数据有一些重要的优点：

1. 可以把相关的数据放在一起。根据主键查询数据时，因为数据和索引在一块，索引只用访问很少的数据页就能获取到所有数据。如果没有使用聚簇索引，每条数据都可能导致一次磁盘 I/O。

2. 数据访问更快。

3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

如果在设计表和查询时能充分利用上面的优点，就能极大地提升性能。聚簇索引的缺点如下：

1. 聚簇索引最大限度地提高了 I/O 密集型应用的性能。但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。

2. 插入速度严重依赖于插入速度。按照主键的顺序插入是加载数据到 InnoDB 中速度最快的方式。但是如果不是按照主键顺序加载数据，那么在加载完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表。

3. 更新聚簇索引列的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置。

4. 基于聚簇索引的表在插入新行，或者主键被更新时导致需要移动行的时候，可能面临“页分裂”的问题。页分裂会导致表占用更多的磁盘空间。

5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。

6. 二级索引（非聚簇索引）可能比想象的更大，因为二级索引的叶子节点包含了引用行的主键列。

7. 二级索引访问需要两次索引查找，而不是一次。对于 InnoDB，自适应哈希索引能够减少这样的重复工作。但是注意：并不是所有的非聚簇索引都能做到一次索引查询就找到行。当行更新的时候可能无法存储在原先的位置，这会导致表中出现行的碎片化或者移动航并在原位置保存“向前指针”，这两种情况都会导致在查询行时需要更多的工作。

**** InnoDB 和 MyISAM 的数据分布对比

MyISAM 中主键索引和其他索引在结构上没有什么不同，它们的叶节点都是列值加上行号（或者数据地址）的组合。主键索引就是个名为 PRIMARY 的唯一非空索引。

InnoDB 支持聚簇索引，聚簇索引的每个叶子节点都包含了主键值、事务 ID、用于事务和 MVCC 的回滚指针以及所有剩余的列。如果主键是一个列前缀索引，InnoDB 也会包含完整的主键列和剩下的其他列。

与 MyISAM 不同的另一点是：InnoDB 的二级索引的叶子节点中存储的不是“行指针“，而是主键值。这样的策略减少了当出现行移动或者数据分页时二级索引的维护工作。使用主键值当做指针会让二级索引占用更多的空间，需要两次索引查找，换来的好处是，InnoDB 在移动行时无需更新二级索引中的这个”指针“。

**** 在 InnoDB 中按主键顺序插入行

如果使用 InnoDB 表的时候没有什么数据需要聚集，可以定义一个代理键作为主键，这种主键的数据应该和应用无关，最简单的方法是使用 AUTO_INCREMENT 自增列。这样可以保证数据列是按顺序写入，对于根据主键做关联操作的性能也会更好。

最好避免随机的（不连续且值的分布范围非常大）聚簇索引，特别是对于 I/O 密集型的应用。例如：从性能的角度考虑，使用 UUID 来作为聚簇索引会很糟糕，它使得局促索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。这种情况下，插入行花费的时间更长，并且索引占用的空间也更大。一方面是因为主键字段更长，另一方面是因为页分裂和碎片导致的。

当主键是自增整数时，因为主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这也正是期望的结果。

当主键是 UUID 时，因为新行的主键值不一定比之前插入的大，所以 InnoDB 无法简单地总是把新行插入到索引的最后，大多数情况下需要插入到已有数据的中间位置，这会增加很多额外的工作，还会导致数据分布不够优化。下面是它的一些缺点：

1. 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有加载到缓存中，InnoDB 在插入之前不得不先找到并从磁盘中读取目标页到内存中。这间导致大量的随机 I/O。

2. 因为写入的乱序的，InnoDB 不得不频繁地做页分裂操作，导致移动大量数据，一次插入最少需要修改三个页而不是一个页。

3. 由于频繁地页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。

在把这些随机值载入到聚簇索引以后，也许需要做一次 OPTIMIZE TABLE 来重建表并优化页的填充。

使用 InnoDB 的时候，应尽可能地按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行。

顺序的主键也并不是总有效的。对于高并发工作负载，在 InnoDB 中按主键顺序插入可能会造成明显的争用。主键的上界会成为热点，因为所有的插入都发生在这里，所以并发插入可能导致间隙所竞争。另一个热点可能是 AUTO_INCREMENT 锁机制，如果遇到这个问题，可以考虑重新设计表或应用，或者更改 innodb_autoinc_lock_mode 配置。

*** 覆盖索引

设计优秀的索引应该考虑到整个查询，而不仅仅是根据 WHERE 条件来创建合适的索引。如果要查询的列全在索引中，MySQL 就可以直接从索引中获取数据，而不需要回表，对于 InnoDB 来说，少了一次主键检索，对于 MyISAM 来说，少了一次地址查找。如果一个索引（注意是一个）覆盖所有需要查询的字段的值，我们就称之为“覆盖索引”。

覆盖索引能够极大地提高性能。优点如下：

1. 索引条目通常远远小于数据行的大小，所以如果只需要读取索引，那 MySQL 就会很大地减少数据访问量。这对缓存的负载很重要，因为这种情况下响应时间大部分花费在数据拷贝上，。覆盖索引对与 I/O 密集型的应用也有帮助，因为索引比数据更小，更容易全部放入到内存中（MyISAM 能够压缩索引使得其更小）。

2. 因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于 I/O 密集型的范围查找会比随机从磁盘读取每一行数据的 I/O 要少得多。对于某些存储引擎（MyISAM 和 Percona EtraDB），甚至可以通过 OPTIMIZE 命令使得索引完全顺序排列。

3. 一些存储引擎如 MyISAM 在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。

4. 由于 InnoDB 的聚簇索引，覆盖索引对 InnoDB 表特别有用。InnoDB 的二级索引在叶子节点中保存了行的主键值，如果查询列只包含二级索引和主键，就不用再进行主键检索了。

不是所有的索引都可以成为覆盖索引。覆盖索引必须要存储索引的值，哈希索引、空间索引和全文索引都存列值，MySQL 中只有 B-Tree 索引可以做覆盖索引。

当发起一个被索引覆盖的查询时，在 EXPLAIN 的 Extra 列可以看到“Using index”的信息。

索引覆盖查询还有很多陷阱可能导致无法实现优化。MySQL 查询优化器会在执行查询前判断是否有一个索引进行覆盖。假设索引覆盖了 WHERE 条件中的字段，但不是整个查询涉及的字段。如果条件为假（false），MySQL 5.5 和更早的版本也总是会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。

示例如下：

EXPLAIN SELECT * FROM products WHERE actor = 'SEAN CARREY' AND title like '%APOLLO%'

这里的索引无法覆盖该查询，原因有两点：

1. 没有任何索引能够覆盖这个查询，因为要查询所有列，没有索引覆盖所有列。不过理论上 MySQL 还有一条捷径可以利用：WHERE 条件中的列由索引覆盖，可以先使用该索引找到对应的 actor，并检查 title 是否匹配，最后回表读取需要的数据行。

2. MySQL 不能在索引中执行 LIKE 操作。这是底层存储引擎 API 的限制，MySQL 5.5 及之前版本只允许在索引中做简单比较操作（等于，不等，大于等）。可以执行左前缀 LIKE，因为可以转化为大于。在索引中无法比较匹配的时候（比如 LIKE %aaa%），MySQL 服务器只能提取数据行的值而不是索引值来作比较。

优化后如下：

EXPLAIN SELECT * FROM products JOIN (SELECT prod_id from products WHERE actor = 'SEAN CARREY' AND title LIKE '%APOLLO%') as t1 ON (t1.prod_id = products.prod_id)

这种优化方式称为延迟关联，因为延迟了对列的访问。查询的第一阶段只返回了 prod_id，拉取的数据比较少，第二阶段根据 prod_id 再次精确获取值。第一阶段用到了覆盖索引（不过 LIKE 的过滤还是在服务器层实现的）。

这种优化方式适用的场景是根据 actor 条件过滤出大量的数据，而加上 title 限制后，只有很少一部分数据满足条件。对于第一种 SQL，MySQL 会将符合 actor 的数据拉取到服务器层，然后根据 title 条件过滤。第二种 SQL，第一步和前一种 SQL 一致，但是由于查询出的数据列少，效率高，第二步根据 prod_id 再查询所有列值。

上面这种优化方式能起作用，主要是因为 MySQL 存储引擎 API 设计的问题，导致需要将数据从存储引擎拉到服务器层，再根据查询条件过滤。MySQL 5.6 中引入了一个特性，叫“索引条件推送”（index condition pushdown），能大大改善现在的查询执行方式，上面介绍的这种技巧就没必要了。

*** 使用索引扫描来做排序

MySQL 有两种方式可以生成有序的结果：通过排序操作；或者通过索引扫描排序。如果 EXPLAIN 出来的 type 列的值为“index”，则说明 MySQL 使用了索引扫描来做排序。

扫描索引是很快的。但是如果索引不能覆盖所需的所有列，每扫描一条记录就要回表一次，这基本都是随机 I/O，因为按照索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在 I/O 密集型的工作负载时。

MySQL 可以使用同一索引既满足排序又用于查找行。设计的时候尽量同时满足这两种任务。
