# 第二章 第一节 信息存储

1. 大多数计算机使用8位的块，或者字节（byte），作为最小的可寻址的内存单元，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字符数组，称为虚拟内存（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合就称为虚拟地址空间。

2. C语言中指针的值都是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向地址处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序的对象可以简单地视为一个字节块，而程序本身就是一个字节序列。

  指针与变量类似，也有两个方面：值和类型。值表示某个对象的地址，类型表示地址所指向位置上存放的对象的类型。

3. 在C语言中，以0x或0X开头的数字常量被认为是十六进制（hexadecimal）的值。字符A~F可以是大写，也可以是小写。

4. 每台计算机都有一个字长（CPU的字长），标识指针数据的标称大小。因为虚拟地址是以一个字来编码的，所以字长决定了虚拟地址空间的最大大小。
  - CPU位数 = CPU寄存器的位数 = CPU能够一次并行处理的数据宽度（位数）= 数据总线宽度

  - CPU为了实现其功能，设计了指令集，也就是CPU支持的全部指令，这是机器语言。计算机的所有功能都是基于CPU的指令集。指令集和CPU位数有关，一般会向后兼容。比如32位指令集兼容16位指令集，64位兼容32位。

  - 操作系统的位数 = 依赖的指令集位数 <= CPU位数

5. 32程序和64位程序区别在与该程序是如何编译的，而不是其运行的机器类型。

6. 程序员应该力图使程序在不同的机器和编译器上可移植，可移植的一个方面就是使程序对不同数据类型的确切大小不敏感。

7. 寻址和字节顺序

  对于跨越多个字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

  排序表示一个对象有两个通用的规则。小端法——最低有效字节在最前面；大段法——最高有效字节在最前面。例如变量int x值为0x01234567，大端法（地址从小到大）：01 23 45 67，小端法（地址从小到大）：67 45 23 01。许多新的处理器是双端法，可以配置成大端或者小端的系统来运行。实际上，一旦选择了特定的操作系统，字节顺序就确定下来了。

  对于大多数应用程序员来说，机器所使用的字符顺序是完全不可见的。但是有时候，字节顺序会成为问题。

  - 在不同类型的机器之间通过网络传输二进制数据时，一个常见的问题是当小端机产生的数据被发送到大端机或者反过来时，接收程序会发现字里的字节成了反序的。为了避免这个问题，网络应用程序的代码编写必须遵循已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器将网络标准转换为它的内部表示。

  - 当阅读表示整型数据的字节序列时字节的顺序也很重要。这通常发生在检查机器级程序时。

  - 当编写规避正常的类型系统的程序时。在C语言中，可以通过使用强制类型转换（cast）或联合（union）来允许以一种数据类型引用一个对象。而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推荐这种编程技巧，但是它们对于系统级编程来说是非常有用的，甚至是必须的。

8. 在C语言中，我们可以用数组表示法来引用指针，也可以使用指针表示法来引用数组元素。

```C
int *int_pointer = {1,2};
int value = int_pointer[1];
```

9. 字符串

  C语言中字符串被编码为一个以null（ASCII码为0）字符结尾的字符数组。每个字符都是由某个标准编码来表示。十进制数x的ASCII码正好是0x3x，null字符的十六进制表示为0x00。使用ASCII码的字符串数据的顺序与机器的字节顺序和字大小规则无关（也就是大小端）（这是因为一个字符的大小为一个字节，不受大小端的影响，只有int，float等大于一个字节的类型才会受影响）。因此文本数据比二进制数据具有更强的平台独立性。

  相同的源程序在不同的机器上编译出来的机器代码是不同的，这是因为不同机器上使用不同且不兼容的指令和编码方式。因此二进制代码是不兼容的，二进制代码很少能在不同机器和操作系统组合之间移植。

  计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。

10. 二进制是计算机编码、存储和操作信息的核心，围绕0和1的研究已经演化出了丰富的数学只是体系。

11. 布尔运算规则：布尔运算与整数运算有很多相似之处

  - 布尔运算 & 对 | 的分配律：a & (b | c) = (a & b) | (a & c)

  - 布尔运算 | 对 & 的分配律：a | (b & c) = (a | b) & (a | c)

  - 整数运算的一个属性是每个值x都有一个加法逆元-x，使得x + (-x) = 0。布尔环也有类似的属性 a ^ a = 0，(a ^ b) ^ a = b

12. 位向量的一个很有用的应用是表示有限集合。我们可以使用位向量[aw-1,...,a0]编码任何子集（A 是 {0,1,...,w-1}的子集，其中ai = 1当且仅当i ∈ A。使用这种编码集合的方法，布尔运算 | 和 & 分别对应集合的并和交，而 ~ 对应集合的补。

13. 位级运算的一个常见用法是实现掩码运算。这里的掩码是一个位模式，表示从一个字中选出的位的集合。表达式~0将生成一个全1的掩码，不管机器的字是多少（是可移植的）。

14. C语言中的逻辑运算＆ | ~，逻辑运算很容易跟位运算搞混，但是它们的功能是完全不一样的。

  逻辑运算认为所有的非零的参数都为TRUE，而参数零为FALSE。它们返回1或者0。按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和其对应的逻辑运算有相同的行为。

  如果对第一格参数求值就可以确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。例如：表达式a && 5/a 不会造成被零除，p && *p++不会导致间接引用空指针。

15. 移位运算

  左移运算 直接丢弃k位高位，然后在右边补k个0

  右移运算 一般而言，机器支持两种形式的右移：逻辑右移和算数右移。逻辑右移在左端补k个0,。算数右移是在左边补k个最高有效位（其实就是符号位）的值。C语言标准没有明确定义对于有符号数应该使用哪种类型的右移。实际上，几乎所有的编译器/机器组合都对有符号数使用算数右移。另外，对于无符号数，右移必须是逻辑的。

  java中，对右移进行了明确的定义，>>表示算数右移，>>>表示逻辑右移。

  移位运算中，如果k大于数据类型的位数w，大多数机器上，移位指令只考虑位移量的低 k % w 位。但是C语言标准并没有规定这种情况下应该怎么做，所以对于C程序来说，最后保证位移量小于操作数的位数。另外，Java中特别要求位移量应该是求模后的结果。

16. 计算机系统中有两种方法来表示整数。一种只能用来表示非负数，一种可以表示负数，零和正数。
