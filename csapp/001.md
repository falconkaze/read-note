# 第一章笔记

1. 信息就是位+上下文
  
计算机系统中所有的信息——包括磁盘文件，内存中的程序，内存中存放的用户数据以及网络上传输的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读取到这些数据时的上下文。

2. C语言是系统级编程的首选，也非常适合应用级程序的编写。但是C的指针比较难理解，并且是导致程序错误的一个常见原因。同时，C语言缺乏对非常有用的抽象的显示支持，例如类、对象和异常。

3. C语言编译系统包含四部分：预处理器、编译器、汇编器和链接器。

  - 预处理阶段：预处理器（CPP）根据预处理命令（也就是#开头的语句），修改原来的C程序，得到另一个C程序，通常是以.i作为文件扩展名。

  - 编译阶段：编译器（CCL）将文本文件hello.i翻译成hello.s，也就是汇编语言程序。

  - 汇编阶段：汇编器（CS）把hello.s翻译成机器语言指令，并把结果保存在目标文件hello.o中，这是一个二进制文件。

  - 链接阶段：链接器（LD）把程序中调用的的库函数的文件合并到程序中，最后得到一个可执行文件。

4. 了解编译系统的好处
  
  - 优化程序性能。现代编译器通常可以生成很好的代码。但是为了在C程序中做出好的编码选择，我们需要了解一些机器代码以及编译器将不同的C语言转化为机器代码的方式。比如，switch和if的效率，函数调用的开销（比如递归和迭代如果选择），while和for效率，指针引用比数组索引更高效？为什么把循环求和的结果放在一个本地变量中，会比将其放到一个通过引用传递过来的参数中，运行起来快很多。为什么只是简单地重新排列了一下算数表达式中的括号就能让函数运行得更快。

  - 理解链接时出现的错误。

  - 避免安全漏洞，比如整数溢出，浮点数不精确。缓存区溢出是造成大多数网络和Internet服务器上安全漏洞的主要原因。

5. 系统的硬件组成

  - 总线
  
  总线是贯穿整个系统的一组电子管道，它负责在各个部件之间传递信息字节。通常总线被设计城传送定长的字节块，也就是字。字中的字节数（即字长）是一个基本的系统参数。一般系统分为32位和64位两种，前者字长为4个字节，后者字长为8个字节。字长限制了系统的内存地址表示，所以32系统支持的最大内存为4GB（2^32bit）。（64位系统应该需要总线等设备的支持）

  - I/O设备

  I/O（输出/输出）设备是系统与外界系统的联系通道，包括键盘鼠标，显示器，磁盘驱动器，光驱，打印机。每一个I/O设备都通过一个控制器或者适配器与I/O总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是I/O设备本身或者系统的主印制电路板（通常称为主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。它们的功能都是在I/O总线和I/O设备之间传递信息。

  - 主存

  从物理上讲，主存是一组动态随机存取存储器（DRAM）芯片组成的；从逻辑上讲，主存是一个线性的字节数组，每个字节都有唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节组成。

  - 处理器

  中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC都指向主存中的某条机器语言指令（即含有这条指令的地址）。

  从系统通电开始，直到系统断电，处理器一直在不断执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新PC，使其指向下一条指令，然后这条指令并不一定和在内存中刚刚执行的命令相邻。这些操作围绕主存，寄存器文件（register file）和算数/逻辑单元（ALU）进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。

  CPU可能会执行的操作。

    1. 加载：从主存中复制一个字节或者一个字到寄存器，并覆盖寄存器原来的内容

    2. 存储：从寄存器赋值一个字节或者一个字到主存的某个位置

    3. 操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算数运算，并将结果存放到寄存器中

    4. 跳转：从指令本身中抽取一个字，并将这个字复制到PC中，以覆盖PC原来的值

  处理器的指令集架构描述的是每条机器代码指令的效果；而处理器的微体系结构描述的是处理器实际上如何实现的。

6. 运行hello程序的过程

  - 初始时，shell程序执行它的指令，等待我们输入第一个指令。当我们键入./hello后，shell程序将字节逐个读入寄存器，然后在放入主存中。

  - 当我们键入回车键时，shell程序知道我们结束了命令的输入。shell执行一系列指令来加载可执行文件hello，这些指令将执行文件中的代码从磁盘复制到主存。（利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。

  - 程序被加载到主存后，处理器就开始执行main程序中的机器语言指令。

7. 高速缓存

  高速缓存存储器（cache memory）是用一种叫做静态随机访问存储器的硬件技术实现的。引入高速缓存之后，系统可以在获得一个很大存储器的同时，访问速度也很快，这是因为高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。

  意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。

  每个计算机系统中的存储设备都被组成了一个存储器层次架构。在这个层次结构中，自上而下，设备的访问速度越来越慢，容量越来越大，每字节的造价也越低。CPU寄存器 -> L1高速缓存SRAM -> L2高速缓存 -> L3高速缓存 -> 主存DRAM -> 本地磁盘 -> 远程存储（分布式文件系统等）

  存储器层次结构的主要思想是上一层的存储器作为下一层存储器的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。

8. 操作系统

  操作系统有两个基本功能：a. 防止硬件被失控的应用程序滥用；b.向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个抽象概念（进程、虚拟内存和文件）来实现这两个功能。文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。

9. 进程

  进程是操作系统对一个正在运行的程序的抽象。并发运行，就是说一个进程的指令和另一个进程的指令是交错执行的。操作系统实现这种交错执行的机制称为上下文切换。操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如PC和寄存器文件的当前值以及主存的内容。在任何时候，单处理器系统都只能执行一个进程的代码。当操作系统决定把控制权从当前进程转移到其他进程时，就会进行上下文切换，即保存当前进程的上下文，恢复新进程的上下文，然后将控制权传递到新进程。

  从一个进程到另一个进程的转换是由操作系统内核（Kernel）管理的。内核是操作系统代码常驻内存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，就会执行一条特殊的系统调用（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。

  注意：内核不是一个单独的进程。它是系统管理全部进程所用代码和数据结构的集合。

10. 线程

  在现代系统中，一个进程实际上是可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程比多进程之间更容易共享数据，并且线程一般来说也比进程更高效。当有多处理器可用时，多线程也是一种使得程序运行更快的方法。

11. 虚拟内存

  虚拟内存为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的。地址空间的底部区域存放用户进程定义的代码和数据。地址是从上到下递减的。

  内存地址从低到高，依次存放的是：
  
  - 程序代码和数据，对于所有进程来说，代码都是从同一个固定地址开始的，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。

  - 堆 代码和数据区后面紧随着的是运行时堆，代码和数据区在进程一开始运行时就指定了大小，而当调用像malloc和free这样的C标准函数时，堆可以在运行时动态地扩展和收缩。

  - 共享库 大约在地址空间的中间部分是一块用来存放像C标准库和数据库这样的共享库的代码和数据的区域。

  - 栈 位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。这个区也可以在程序执行期间动态扩展和收缩。特别地，每次我们调用一个函数时，栈会增长，从函数返回时，栈会收缩。

  - 内核虚拟内存 地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。它们必须通过调用内核来执行这些操作。

  虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储到磁盘上，然后用主存作为磁盘的高速缓存。

12. 文件

  文件就是字节序列。每个I/O设备，包括磁盘，键盘，显示器，甚至网络，都可以看成文件。系统中所有的输入输出都是通过一小组称为Unix I/O的系统函数调用读写文件来实现的。

  文件向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各种各样的I/O设备。例如，处理磁盘内容并不需要知道具体的磁盘技术。

13. Amdahl定律

  当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。假设系统某部分执行时间占总时间的α，而这部分性能提升比例为k（优化后时间为之前的1/k），那么加速比为S = 1/((1-α)+α/k)。

  这个定律主要观点：想要显著加速整个系统，必须提升全系统中相当大的部分的速度。另外，只把系统一部分优化到极致不如优化整个系统，因为优化越好，执行时间越短，优化对整体的效果越不明显。

14. 并发和并行

  并发（concurrency)指一个同时具有多个活动的系统；并行（parallelism）指的是用并发来使一个系统运行得更快。

  - 线程级并发

  多核处理器具有多个CPU，每个核都有自己的高速缓存（L1，L2），共享更高层次的高速缓存（L3）。这会导致一个问题，如果一个程序由多个核运行，由于使用的高速缓存不同，可能会导致每个核看到的共享数据数值不同。

  超线程，也叫同时多线程（siultaneous multi-threading），是一项允许一个CPU执行多个控制流的技术。

  多核处理器和超线程可以从两方面提升系统的性能。减少了在执行多个任务时模拟并发的需要，不用频繁切换进程上下文。其次，它可以使得应用程序运行得更快，这要求程序必须是以多线程的方式书写的，这些线程可以并行地高效执行。

  - 指令级并行

  在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。虽然每条指令执行需要20个或者更多的时钟周期，但是现代处理器可以保持每个时钟周期2~4个指令的执行效率。这是因为处理器用了很多聪明的技巧来同时处理多达100条指令，例如使用流水线。

  如果处理器可以达到比一个周期一条指令更快的执行效率，就称为超标量处理器。

  - 单指令、多数据并行

  在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即SIMD并行。例如：较新几代的Intel和AMD处理器都具有并行地对8对但进度浮点数做加法的指令。

  提供这些SIMD指令多是为了提高处理影像，声音和视频应用数据的执行速度。

15. 抽象

  抽象是计算机科学中最为重要的概念之一。例如：为一组函数规定一个简单的应用程序接口（API）就是一个很好的编程习惯，程序员无需了解它的内部原理就可以使用这些代码；指令集架构提供了对实际处理器硬件的抽象；虚拟机提供了对整个计算机系统的抽象，包括操作系统、处理器和程序。。不同的编程语言提供不同形式和等级的抽象支持。
